"""CompilationEngine module.

TODO: rewrite

Effects the actual compilation output. Gets its input from a JackTokenizer 
  and emits its parsed structure into an output file/stream. The output 
  is generated by a series of compilexxx() routines, one for every syntactic
  element xxx of the Jack grammar. The contract between these routines is that each
  compilexxx() routine should read the syntactic construct xxx from the input,
  advance() the tokenizer exactly beyond xxx, and output the parsing of xxx. Thus,
  compilexxx() may only be called if indeed xxx is the next syntactic element of the input.
"""


from functools import wraps
from JackTokenizer import *
from SymbolTable import *
from VMWriter import *


# TODO: probably remove or rewrite
# PURPOSE:  Generates marked-up output for a non-terminal element.
# <xxx>
#        Recursive code for the body of the xxx element.
# </xxx>
def wrap_non_terminal(func) -> None:

    @wraps(func)
    def non_terminal_wrapper(*args, **kwargs):
        
        non_terminal = re.split('_', func.__name__)[1] # get non-terminal name of an element

        args[0].write(args[0].compose_non_terminal(non_terminal))
        args[0].indent_level += 1

        func(*args, **kwargs)

        args[0].indent_level -= 1
        args[0].write(args[0].compose_non_terminal(f'/{non_terminal}'))

    return non_terminal_wrapper


class CompilationEngine():

    # TODO: rewrite eat() so if true it gets next token by calling forward()

    # PURPOSE:  Creates a new compilation engine with the given input and output.
    #           The next routine called must be compileClass().
    # ASSUMES:  Passed paths are absolute.
    def __init__(self, input_path, output_path) -> None:

        self.JT = JackTokenizer(input_path) # tokenizer
        self.VMW = VMWriter(output_path) # file writer
        self.ST = SymbolTable() # symbol table

        self.indent_level = 0  # indentation level

        self.className = None # name of the current compiling class
        self.subrouniteType = None # type of the current compiling subroutine
        self.subrouniteName = None # name of the current compiling subroutine
        self.termName = None # name of the current compiling term
        self.numArgs = 0 # amount of function arguments

        self.forward() # prepare first token to parse

    
    # PURPOSE: Resets subroutine symbol table and unique names 
    def reset_subroutine(self) -> None:
        self.ST.start_subroutine() # NOTE: resets symbol table
        # TODO: should probably reset after each subroutine compilation 
        self.uniqueWhile = 0 # num to indicate unique while loop
        self.uniqueIf = 0 # num to indicate unique if-else statement


    # PURPOSE: Writes an op command into an output file.
    def write_op(self, op: str) -> None:
        if op == '+':
            self.VMW.write_arithmetic(AnLCommands.ADD)
        elif op == '-':
            self.VMW.write_arithmetic(AnLCommands.SUB)
        elif op == '*':
            self.VMW.write_call('Math.multiply', 2)
        elif op == '/':
            self.VMW.write_call('Math.divide', 2)
        elif op == '&':
            self.VMW.write_arithmetic(AnLCommands.AND)
        elif op == '|':
            self.VMW.write_arithmetic(AnLCommands.OR)
        elif op == '<':
            self.VMW.write_arithmetic(AnLCommands.LT)
        elif op == '>':
            self.VMW.write_arithmetic(AnLCommands.GT)
        elif op == '=':
            self.VMW.write_arithmetic(AnLCommands.EQ)


    # PURPOSE: Writes a unary op command into an output file.
    def write_unary_op(self, uOp: str) -> None:
        if uOp == '-':
            self.VMW.write_arithmetic(AnLCommands.NEG)
        elif uOp == '~':
            self.VMW.write_arithmetic(AnLCommands.NOT)


    # PURPOSE:  Writes a line into an output file.
    # CHANGES:  file
    def write(self, line) -> None:
        self.out_file.write(line)
        

    # PURPOSE:  Closes output file and frees the memory.
    # CHANGES:  file
    def dispose(self) -> None:
        self.out_file.close()


    # PURPOSE:  Advances tokenizer by one token.
    # CHANGES:  JackTokenizer
    def forward(self) -> None:
        if self.JT.hasMoreTokens(): self.JT.advance()


    # PURPOSE:  Returns an XML tag for a passed non-terminal element.
    # RETURNS:  str
    def compose_non_terminal(self, word) -> str:
        indent = self.indent_level * '  ' # 2 spaces
        return f'{indent}<{word}>\n'


    # PURPOSE:  Returns an XML line for a current terminal element.
    # RETURNS:  str
    def compose_terminal(self) -> str:
        indent = self.indent_level * '  ' # 2 spaces
        token_type = self.JT.tokenType()
        token = self.get_current_token(token_type)
        return f'{indent}<{token_type.value}> {token} </{token_type.value}>\n'


    # TODO: maybe move inside ^^
    # PURPOSE:  Returns current token represented as a string.
    # RETURNS:  str
    def get_current_token(self, token_type: LexicalElement) -> str:
        if token_type == LexicalElement.KEYWORD: return self.JT.keyWord()
        elif token_type == LexicalElement.SYMBOL: return self.JT.symbol()
        elif token_type == LexicalElement.IDENTIFIER: return self.JT.identifier()
        elif token_type == LexicalElement.INT_CONST: return self.JT.intVal()
        elif token_type == LexicalElement.STRING_CONST: return self.JT.stringVal()

    
    # PURPOSE:  Writes current token element as an XML line in the output file 
    #           and advances the tokenizer.
    # CHANGES:  file, tokenizer
    def write_terminal(self) -> None:
        self.out_file.write(self.compose_terminal())
        self.forward()


    # PURPOSE:  Compares current token with a passed string.
    # RETURNS:  bool
    def eat(self, string) -> bool:
        return self.JT.current_token == string


    # PURPOSE:  Checks whether or not current token is keyword or identifier.
    #           Currently purpose is: int | char | boolean | className ?
    # RETURNS:  bool
    def isKeywordOrIdentifier(self) -> bool:
        token_type = self.JT.tokenType()
        return token_type == LexicalElement.KEYWORD or token_type == LexicalElement.IDENTIFIER


    # PURPOSE:  Checks whether or not current token is identifier or not.
    #           Current target is: className | subroutineName | varName
    # RETURNS:  bool
    def isIdentifier(self) -> bool:
        return self.JT.tokenType() == LexicalElement.IDENTIFIER

    # PURPOSE:  Checks whether or not current token is keyword or not.
    #           Current target is: true | false | null | this
    # RETURNS:  bool
    def isKeyword(self) -> bool:
        return self.JT.tokenType() == LexicalElement.KEYWORD


    # PURPOSE:  Checks whether or not current token is stringConstant or not.
    # RETURNS:  bool
    def isStringConstant(self) -> bool:
        return self.JT.tokenType() == LexicalElement.STRING_CONST

    
    # PURPOSE:  Checks whether or not current token is integerConstant or not.
    # RETURNS:  bool
    def isIntegerConstant(self) -> bool:
        return self.JT.tokenType() == LexicalElement.INT_CONST

    
    # PURPOSE:  Checks whether or not current token is op or not.
    # RETURNS:  bool
    def isOp(self) -> bool:
        op = ['+', '-', '*', '/', '&', '|', '<', '>', '=']
        return self.JT.current_token in op

    
    # PURPOSE:  Checks whether or not current token is unaryOp or not.
    # RETURNS:  bool
    def isUnaryOp(self) -> bool:
        unaryOp = ['-', '~']
        return self.JT.current_token in unaryOp
    

    # PURPOSE:  Compiles a complete class.
    # ASSUMES:  Already has a token to start with.
    # class -> className -> { -> classVarDec* -> subroutineDec* -> }
    def compile_class(self) -> None:
        # class
        if self.eat('class'):
            self.forward()
            # className
            if self.isIdentifier():
                self.className = self.JT.current_token
                self.forward()
                # {
                if self.eat('{'):
                    self.forward()
                    # classVarDec*
                    while self.eat('static') or self.eat('field'):
                        self.compile_classVarDec()
                    
                    # TODO: subroutineDec*
                    while self.eat('method') or self.eat('function') or self.eat('constructor'):
                        self.subrouniteType = self.JT.current_token
                        self.compile_subroutineDec()
                    
                    if self.eat('}'):
                        self.forward()


    # PURPOSE:  Compiles a static declaration or a field declaration.
    # static | field -> type -> varName -> (, -> varName )* -> ;
    def compile_classVarDec(self) -> None:
        # static | field # NOTE: previously checked
        if self.eat('static'):
            kind = STKind.STATIC
        elif self.eat('field'):
            kind = STKind.FIELD
        self.forward()
        # type
        if self.isKeywordOrIdentifier():
            type_ = self.JT.current_token
            self.forward()
            # varName
            if self.isIdentifier():
                name = self.JT.current_token
                self.forward()
                self.ST.define(name, type_, kind)
                # (, -> varName )*
                while not(self.eat(';')):
                    name = self.JT.current_token
                    self.ST.define(name, type_, kind)
                    self.forward()
                self.forward()
    

    # PURPOSE:  Compiles a complete method, function, or constructor.
    # constructor | function | method -> void | type -> subroutineName -> ( -> parameterList -> ) -> subroutineBody
    def compile_subroutineDec(self) -> None:
        # constructor | function | method # NOTE: previously checked
        # TODO: change behavior for method call
        self.reset_subroutine() # NOTE: resets sub ST and unique num
        self.forward()
        # void | type
        if self.isKeywordOrIdentifier(): 
            # NOTE: TODO: void etc
            self.forward()
            # subroutineName
            if self.isIdentifier():
                self.subrouniteName = self.JT.current_token
                self.forward()
                # (
                if self.eat('('):
                    self.forward()
                    # parameterList
                    self.compile_parameterList()
                    # )
                    if self.eat(')'):
                        self.forward()
                        # subroutineBody
                        self.compile_subroutineBody()
                        

    # PURPOSE:  Compiles a possibly empty parameter list, not including the enclosing ().
    # type -> varName -> (, -> varName)*
    def compile_parameterList(self) -> None:
        # type
        if self.isKeywordOrIdentifier():
            type_ = self.JT.current_token
            self.forward()
            # varName
            name = self.JT.current_token
            kind = STKind.ARG
            self.ST.define(name, type_, kind)
            self.forward()
            # (, -> varName)*
            while not self.eat(')'):
                if self.isIdentifier():
                    name = self.JT.current_token
                    self.ST.define(name, type_, kind)
                self.forward()


    # PURPOSE:  Compiles a body of a subroutine.
    # { -> varDec* -> statements -> }
    def compile_subroutineBody(self) -> None:
        # {
        if self.eat('{'):
            self.forward()
            # varDec*
            while self.eat('var'):
                self.compile_varDec()
            self.VMW.write_function(f'{self.className}.{self.subrouniteName}', self.ST.var_count(STKind.VAR))

            if self.subrouniteType == 'constructor':
                self.VMW.write_push('constant', self.ST.var_count(STKind.FIELD))
                self.VMW.write_call('Memory.alloc', 1) # one argument
                self.VMW.write_pop('pointer', 0)

            if self.subrouniteType == 'method':
                self.VMW.write_push('argument', 0)
                self.VMW.write_pop('pointer', 0)

            # statements
            self.compile_statements()
            # }
            if self.eat('}'):
                self.forward()


    # PURPOSE:  Compiles a var declaration.
    # var -> type -> varName -> (, -> varName)* -> ;
    def compile_varDec(self) -> None:
        # var
        if self.eat('var'):
            kind = STKind.VAR
            self.forward()
            # type
            if self.isKeywordOrIdentifier():
                type_ = self.JT.current_token
                self.forward()
                # varName
                if self.isIdentifier():
                    name = self.JT.current_token
                    self.ST.define(name, type_, kind)
                    self.forward()
                    # (, -> varName)*
                    while not(self.eat(';')):
                        if self.isIdentifier():
                            name = self.JT.current_token
                            self.ST.define(name, type_, kind)
                        self.forward()
                    # ;
                    if self.eat(';'):
                        self.forward()
    
    
    # PURPOSE:  Compiles a sequence of statements, not including theenclosing {}.
    # statement*
    def compile_statements(self) -> None:
        # statement*
        while True:
            if self.eat('do'): 
                self.compile_doStatement()
            elif self.eat('if'): 
                self.compile_ifStatement()
            elif self.eat('let'): 
                self.compile_letStatement()
            elif self.eat('return'):
                self.compile_returnStatement()
            elif self.eat('while'):
                self.compile_whileStatement()
            else:
                break #print("BREAK ON EXHAUST")
    

    # PURPOSE:  Compiles a do statement.
    # do -> subroutineCall -> ;
    def compile_doStatement(self) -> None: 
        # do # NOTE: previously checked
        self.forward()
        # subroutineCall
        if self.isIdentifier():
            # TODO: write logic: subroutineCall and compile_term
            if self.ST.type_of(self.JT.current_token) is not None:
                kind = self.ST.kind_of(self.JT.current_token)
                self.VMW.write_push(kind.value, 0)
            self.termName = ''
            self.compile_subroutineCall()
            # ;
            if self.eat(';'):
                self.VMW.write_pop('temp', 0) # TODO: temp cuz 0 in stack?
                self.forward()


    # PURPOSE: Compiles a subroutine call.
    # subroutineName -> ( -> expressionList -> )
    # or
    # className | varName -> . -> subroutineName -> ( -> expressionList-> )
    def compile_subroutineCall(self) -> None:
        # subroutineName | className | varName # NOTE: previously checked
        self.numArgs = 0
        className = self.ST.type_of(self.JT.current_token)
        # TODO: write logic: do statement and compileTerm
        if className is not None:
            self.termName += className
            self.numArgs += 1
        else:
            self.termName += self.JT.current_token
        self.forward()
        # .
        if self.eat('.'):
            self.termName += self.JT.current_token
            self.forward()
            # subroutineName
            if self.isIdentifier():
                self.termName += self.JT.current_token
                self.forward()
        if not '.' in self.termName: # called function corresponds to a method
            self.VMW.write_push('pointer', 0)
            self.termName = f'{self.className}.{self.termName}' 
            self.numArgs += 1
        # (
        if self.eat('('):
            self.forward()
            self.compile_expressionList()
            # )
            if self.eat(')'):
                self.VMW.write_call(self.termName, self.numArgs)
                self.forward()


    # PURPOSE:  Compiles an if statement.
    # if -> ( -> expression -> ) -> { -> statements -> } -> ( else -> { -> statements -> } )?
    def compile_ifStatement(self) -> None: 
        # if # NOTE: previously checked
        L1 = f'IF_TRUE{self.uniqueIf}'
        L2 = f'IF_FALSE{self.uniqueIf}'
        L3 = f'IF_END{self.uniqueIf}'
        self.uniqueIf += 1
        self.forward()
        # (
        if self.eat('('):
            self.forward()
            # expression
            self.compile_expression()
            self.VMW.write_if(L1) # goto if
            self.VMW.write_goto(L2) # goto else
            # )
            if self.eat(')'):
                self.forward()
                # {
                if self.eat('{'):
                    self.VMW.write_label(L1) # if
                    self.forward()
                    # statements
                    self.compile_statements()
                    # }
                    if self.eat('}'):
                        self.forward()
                    # else
                    if self.eat('else'):
                        self.VMW.write_goto(L3) # goto end
                        self.VMW.write_label(L2) # else
                        self.forward()
                        # {
                        if self.eat('{'):
                            self.forward()
                            # statements
                            self.compile_statements()
                            # }
                            if self.eat('}'):
                                self.forward()
                                self.VMW.write_label(L3) # label end
                    else: # no else
                        self.VMW.write_label(L2) # label false


    # PURPOSE:  Compiles a let statement.
    # let -> varName -> ([ -> expression -> ])? -> = -> expression -> ;

    # TODO: look up each variable in symbol table, if not found, throw an error

    def compile_letStatement(self) -> None: 
        # let # NOTE: previously checked
        self.forward()
        # varName
        if self.isIdentifier():
            name = self.JT.current_token
            index = self.ST.index_of(name)
            kind = self.ST.kind_of(name).value
            self.forward()
            ## TODO: ([ -> expression -> ])?
            #if self.eat('['):
            #    self.write_terminal()
            #    # expression
            #    self.compile_expression()
            #    # ]
            #    if self.eat(']'):
            #        self.write_terminal()
            # =
            if self.eat('='):
                self.forward()
                # expression
                self.compile_expression()
                # ;
                if self.eat(';'):
                    self.forward()
                    self.VMW.write_pop(kind, index)

    
    # PURPOSE:  Compiles a return statement.
    # return -> expression? -> ;
    def compile_returnStatement(self) -> None: 
        # return # NOTE: previously checked
        self.forward()
        # expresssion?
        if not self.eat(';'):
            self.compile_expression()
        else:
            self.VMW.write_push('constant', 0)
        # ;
        if self.eat(';'):
            self.VMW.write_return()
            self.forward()


    # PURPOSE:  Compiles a while statement.
    # while -> ( -> expression -> ) -> { -> statements -> }
    def compile_whileStatement(self) -> None: 
        # while # NOTE: previously checked
        L1 = f'WHILE_EXP{self.uniqueWhile}'
        L2 = f'WHILE_END{self.uniqueWhile}'
        self.uniqueWhile += 1
        self.VMW.write_label(L1) # label L1
        self.forward()
        # (
        if self.eat('('):
            self.forward()
            # expression
            self.compile_expression() # compiled expression
            self.write_unary_op('~') # not
            self.VMW.write_if(L2) # if-goto L2
            # )
            if self.eat(')'):
                self.forward()
                # {
                if self.eat('{'):
                    self.forward()
                    # statements
                    self.compile_statements() # compiled statements
                    self.VMW.write_goto(L1) # goto L1
                    # }
                    if self.eat('}'):
                        self.VMW.write_label(L2) # label L2
                        self.forward()


    # PURPOSE:  Compiles an expression.
    # term -> (op -> term)*
    def compile_expression(self) -> None:
        # term
        self.compile_term()
        # op*
        while self.isOp():
            op = self.JT.current_token
            self.forward()
            # term
            self.compile_term()
            self.write_op(op)
    

    # PURPOSE: Compiles a term.
    # + integerConstant | + stringConstant | + keywordConstant | 
    # + varName | + varName [ expression ] | + varName . subroutineCall | 
    # + ( expression ) | + unaryOp term
    def compile_term(self) -> None:
        # integerConstant
        if self.isIntegerConstant():
            self.VMW.write_push('constant', self.JT.current_token)
            self.forward()
        # TODO: stringConstant
        elif self.isStringConstant():
            print("STRING CONSTANT")
            pass
        # keywordConstant
        elif self.isKeyword():
            # false | null
            if self.JT.current_token == 'false' or self.JT.current_token == 'null':
                self.VMW.write_push('constant', 0)
            elif self.JT.current_token == 'this':
                self.VMW.write_push('pointer', 0)
            # true
            else:
                self.VMW.write_push('constant', 0)
                self.write_unary_op('~')
            self.forward()
        # varName
        elif self.isIdentifier():
            # TODO: search name in a symbol table, if not found, throw an error
            name = self.JT.current_token
            self.forward()
            # . subroutineCall
            if self.eat('.'):
                # TODO: write logic: do statement and subroutineCall
                self.termName = name
                self.termName += self.JT.current_token
                self.forward()
                # subroutineCall
                self.compile_subroutineCall()
            else:
                segment = self.ST.kind_of(name).value
                index = self.ST.index_of(name)
                self.VMW.write_push(segment, index)

            ## TODO: [ expression ]
            #if self.eat('['):
            #    self.write_terminal()
            #    # expression
            #    self.compile_expression()
            #    # ]
            #    if self.eat(']'):
            #        self.write_terminal()

        # ( expression )
        elif self.eat('('):
            self.forward()
            # expression
            self.compile_expression()
            # )
            if self.eat(')'):
                self.forward()
        # unaryOp term
        elif self.isUnaryOp():
            unaryOp = self.JT.current_token
            self.forward()
            # term
            self.compile_term()
            # NOTE: neg or not
            self.write_unary_op(unaryOp)


    # PURPOSE:  Compiles a (possibly empty) comma-separated list of expressions.
    # ( expression -> (, -> expression)* )?
    def compile_expressionList(self) -> None:
        while not self.eat(')'):
            # ,
            if self.eat(','):
                self.forward()
            # expressison
            self.compile_expression()
            self.numArgs += 1