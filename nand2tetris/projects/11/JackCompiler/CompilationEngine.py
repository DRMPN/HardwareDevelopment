"""CompilationEngine module.

TODO: rewrite

Effects the actual compilation output. Gets its input from a JackTokenizer 
  and emits its parsed structure into an output file/stream. The output 
  is generated by a series of compilexxx() routines, one for every syntactic
  element xxx of the Jack grammar. The contract between these routines is that each
  compilexxx() routine should read the syntactic construct xxx from the input,
  advance() the tokenizer exactly beyond xxx, and output the parsing of xxx. Thus,
  compilexxx() may only be called if indeed xxx is the next syntactic element of the input.
"""


from functools import wraps
from JackTokenizer import *
from SymbolTable import *
from VMWriter import *


# TODO: probably remove or rewrite
# PURPOSE:  Generates marked-up output for a non-terminal element.
# <xxx>
#        Recursive code for the body of the xxx element.
# </xxx>
def wrap_non_terminal(func) -> None:

    @wraps(func)
    def non_terminal_wrapper(*args, **kwargs):
        
        non_terminal = re.split('_', func.__name__)[1] # get non-terminal name of an element

        args[0].write(args[0].compose_non_terminal(non_terminal))
        args[0].indent_level += 1

        func(*args, **kwargs)

        args[0].indent_level -= 1
        args[0].write(args[0].compose_non_terminal(f'/{non_terminal}'))

    return non_terminal_wrapper


class CompilationEngine():

    # PURPOSE:  Creates a new compilation engine with the given input and output.
    #           The next routine called must be compileClass().
    # ASSUMES:  Passed paths are absolute.
    def __init__(self, input_path, output_path) -> None:

        self.JT = JackTokenizer(input_path) # tokenizer
        self.VMW = VMWriter(output_path) # file writer
        self.ST = SymbolTable() # symbol table

        self.indent_level = 0  # indentation level

        self.className = None # name of the current compiling class
        self.subrouniteName = None # name of the current compiling subroutine
        self.termName = None # name of the current compiling term
        self.numArgs = 0 # amount of function arguments
        
        #try: 
        #    self.out_file = open(output_path, 'w')
        #except OSError: 
        #    sys.exit(f'Unable to create {output_path}')

        self.forward() # prepare first token to parse

    
    # PURPOSE:  Writes a line into an output file.
    # CHANGES:  file
    def write(self, line) -> None:
        self.out_file.write(line)
        

    # PURPOSE:  Closes output file and frees the memory.
    # CHANGES:  file
    def dispose(self) -> None:
        self.out_file.close()


    # PURPOSE:  Advances tokenizer by one token.
    # CHANGES:  JackTokenizer
    def forward(self) -> None:
        if self.JT.hasMoreTokens(): self.JT.advance()


    # PURPOSE:  Returns an XML tag for a passed non-terminal element.
    # RETURNS:  str
    def compose_non_terminal(self, word) -> str:
        indent = self.indent_level * '  ' # 2 spaces
        return f'{indent}<{word}>\n'


    # PURPOSE:  Returns an XML line for a current terminal element.
    # RETURNS:  str
    def compose_terminal(self) -> str:
        indent = self.indent_level * '  ' # 2 spaces
        token_type = self.JT.tokenType()
        token = self.get_current_token(token_type)
        return f'{indent}<{token_type.value}> {token} </{token_type.value}>\n'


    # TODO: maybe move inside ^^
    # PURPOSE:  Returns current token represented as a string.
    # RETURNS:  str
    def get_current_token(self, token_type: LexicalElement) -> str:
        if token_type == LexicalElement.KEYWORD: return self.JT.keyWord()
        elif token_type == LexicalElement.SYMBOL: return self.JT.symbol()
        elif token_type == LexicalElement.IDENTIFIER: return self.JT.identifier()
        elif token_type == LexicalElement.INT_CONST: return self.JT.intVal()
        elif token_type == LexicalElement.STRING_CONST: return self.JT.stringVal()

    
    # PURPOSE:  Writes current token element as an XML line in the output file 
    #           and advances the tokenizer.
    # CHANGES:  file, tokenizer
    def write_terminal(self) -> None:
        self.out_file.write(self.compose_terminal())
        self.forward()


    # PURPOSE:  Compares current token with a passed string.
    # RETURNS:  bool
    def eat(self, string) -> bool:
        return self.JT.current_token == string


    # PURPOSE:  Checks whether or not current token is keyword or identifier.
    #           Currently purpose is: int | char | boolean | className ?
    # RETURNS:  bool
    def isKeywordOrIdentifier(self) -> bool:
        token_type = self.JT.tokenType()
        return token_type == LexicalElement.KEYWORD or token_type == LexicalElement.IDENTIFIER


    # PURPOSE:  Checks whether or not current token is identifier or not.
    #           Current target is: className | subroutineName | varName
    # RETURNS:  bool
    def isIdentifier(self) -> bool:
        return self.JT.tokenType() == LexicalElement.IDENTIFIER

    # PURPOSE:  Checks whether or not current token is keyword or not.
    #           Current target is: true | false | null | this
    # RETURNS:  bool
    def isKeyword(self) -> bool:
        return self.JT.tokenType() == LexicalElement.KEYWORD


    # PURPOSE:  Checks whether or not current token is stringConstant or not.
    # RETURNS:  bool
    def isStringConstant(self) -> bool:
        return self.JT.tokenType() == LexicalElement.STRING_CONST

    
    # PURPOSE:  Checks whether or not current token is integerConstant or not.
    # RETURNS:  bool
    def isIntegerConstant(self) -> bool:
        return self.JT.tokenType() == LexicalElement.INT_CONST

    
    # PURPOSE:  Checks whether or not current token is op or not.
    # RETURNS:  bool
    def isOp(self) -> bool:
        op = ['+', '-', '*', '/', '&', '|', '<', '>', '=']
        return self.JT.current_token in op

    
    # PURPOSE:  Checks whether or not current token is unaryOp or not.
    # RETURNS:  bool
    def isUnaryOp(self) -> bool:
        unaryOp = ['-', '~']
        return self.JT.current_token in unaryOp
    

    # PURPOSE:  Compiles a complete class.
    # ASSUMES:  Already has a token to start with.
    # class -> className -> { -> classVarDec* -> subroutineDec* -> }
    #@wrap_non_terminal
    def compile_class(self) -> None:
        # class
        if self.eat('class'):
            self.forward()
            # className
            if self.isIdentifier():
                self.className = self.JT.current_token
                self.forward()
                # {
                if self.eat('{'):
                    self.forward()

                    ## TODO: classVarDec*
                    #while self.eat('static') or self.eat('field'):
                    #    self.compile_classVarDec()

                    # subroutineDec*
                    while self.eat('constructor') or self.eat('function') or self.eat('method'):
                        self.compile_subroutineDec()
                    if self.eat('}'):
                        self.forward()


    # PURPOSE:  Compiles a static declaration or a field declaration.
    # static | field -> type -> varName -> (, -> varName )* -> ;
    @wrap_non_terminal
    def compile_classVarDec(self) -> None:
        # static | field # NOTE: previously checked
        self.write_terminal()
        # type
        if self.isKeywordOrIdentifier():
            self.write_terminal()
            # varName
            if self.isIdentifier():
                self.write_terminal()
                # (, -> varName )*
                while not(self.eat(';')):
                    self.write_terminal()
                self.write_terminal()
    

    # PURPOSE:  Compiles a complete method, function, or constructor.
    # constructor | function | method -> void | type -> subroutineName -> ( -> parameterList -> ) -> subroutineBody
    #@wrap_non_terminal
    def compile_subroutineDec(self) -> None:
        # constructor | function | method # NOTE: previously checked
        # TODO: change behavior for method call
        self.ST.start_subroutine() # NOTE: resets symbol table
        self.forward()
        # void | type
        if self.isKeywordOrIdentifier(): 
            # NOTE: TODO: void etc
            self.forward()
            # subroutineName
            if self.isIdentifier():
                self.subrouniteName = self.JT.current_token
                self.forward()
                # (
                if self.eat('('):
                    self.forward()
                    # parameterList
                    self.compile_parameterList()
                    # )
                    if self.eat(')'):
                        self.forward()
                        # subroutineBody
                        self.compile_subroutineBody()
                        

    # PURPOSE:  Compiles a possibly empty parameter list, not including the enclosing ().
    # type -> varName -> (, -> varName)*
    def compile_parameterList(self) -> None:
        # type
        if self.isKeywordOrIdentifier():
            type_ = self.JT.current_token
            self.forward()
            # varName
            name = self.JT.current_token
            kind = STKind.ARG
            self.ST.define(name, type_, kind)
            self.forward()
            # (, -> varName)*
            while not self.eat(')'):
                if self.isIdentifier():
                    name = self.JT.current_token
                    self.ST.define(name, type_, kind)
                self.forward()


    # PURPOSE:  Compiles a body of a subroutine.
    # { -> varDec* -> statements -> }
    #@wrap_non_terminal
    def compile_subroutineBody(self) -> None:
        # {
        if self.eat('{'):
            self.forward()
            # varDec*
            while self.eat('var'):
                self.compile_varDec()
            self.VMW.write_function(f'{self.className}.{self.subrouniteName}', self.ST.var_count(STKind.VAR))
            # statements
            self.compile_statements()
            # }
            if self.eat('}'):
                self.forward()


    # PURPOSE:  Compiles a var declaration.
    # var -> type -> varName -> (, -> varName)* -> ;
    #@wrap_non_terminal
    def compile_varDec(self) -> None:
        # var
        if self.eat('var'):
            kind = STKind.VAR
            self.forward()
            # type
            if self.isKeywordOrIdentifier():
                type_ = self.JT.current_token
                self.forward()
                # varName
                if self.isIdentifier():
                    name = self.JT.current_token
                    self.ST.define(name, type_, kind)
                    self.forward()
                    # (, -> varName)*
                    while not(self.eat(';')):
                        if self.isIdentifier():
                            name = self.JT.current_token
                            self.ST.define(name, type_, kind)
                        self.forward()
                    # ;
                    if self.eat(';'):
                        self.forward()
    
    
    # PURPOSE:  Compiles a sequence of statements, not including theenclosing {}.
    # statement*
    #@wrap_non_terminal
    def compile_statements(self) -> None:
        # statement*
        while True:
            if self.eat('do'): 
                self.compile_doStatement()
            elif self.eat('if'): 
                print("IF")
                self.compile_ifStatement()
            elif self.eat('let'): 
                self.compile_letStatement()
            elif self.eat('return'):
                self.compile_returnStatement()
            elif self.eat('while'):
                print("WHILE")
                break
                self.compile_whileStatement()
            else:
                break #print("BREAK ON EXHAUST")
    

    # PURPOSE:  Compiles a do statement.
    # do -> subroutineCall -> ;
    #@wrap_non_terminal
    def compile_doStatement(self) -> None: 
        # do # NOTE: previously checked
        self.forward()
        # subroutineCall
        if self.isIdentifier():
            self.termName = ''
            self.compile_subroutineCall()
            # ;
            if self.eat(';'):
                # TODO: temp cuz 0 in stack?
                self.VMW.write_pop('temp', 0)
                self.forward()


    # PURPOSE: Compiles a subroutine call.
    # subroutineName -> ( -> expressionList -> )
    # or
    # className | varName -> . -> subroutineName -> ( -> expressionList-> )
    def compile_subroutineCall(self) -> None:
        # subroutineName | className | varName # NOTE: previously checked
        self.termName += self.JT.current_token
        self.forward()
        # .
        if self.eat('.'):
            self.termName += self.JT.current_token
            self.forward()
            # subroutineName
            if self.isIdentifier():
                self.termName += self.JT.current_token
                self.forward()
        # (
        if self.eat('('):
            self.forward()
            self.compile_expressionList()
            # )
            if self.eat(')'):
                self.VMW.write_call(self.termName, self.numArgs)
                self.forward()


    # PURPOSE:  Compiles an if statement.
    # if -> ( -> expression -> ) -> { -> statements -> } -> ( else -> { -> statements -> } )?
    # TODO: unique labels
    # TODO: rules:
    """
            compiled (expression)
            not
            if-goto L1
            compiled (statements1)
            goto L2
        label L1
            compiled (statements2)
        label L2
            ...
    """
    #@wrap_non_terminal
    def compile_ifStatement(self) -> None: 
        # if # NOTE: previously checked
        # TODO: negate according to rules
        self.write_terminal()
        # (
        if self.eat('('):
            self.write_terminal()
            # expression
            self.compile_expression()
            # )
            if self.eat(')'):
                self.write_terminal()
                # {
                if self.eat('{'):
                    self.write_terminal()
                    # statements
                    self.compile_statements()
                    # }
                    if self.eat('}'):
                        self.write_terminal()
                    # else
                    if self.eat('else'):
                        self.write_terminal()
                        # {
                        if self.eat('{'):
                            self.write_terminal()
                            # statements
                            self.compile_statements()
                            # }
                            if self.eat('}'):
                                self.write_terminal()


    # PURPOSE:  Compiles a let statement.
    # let -> varName -> ([ -> expression -> ])? -> = -> expression -> ;
    #@wrap_non_terminal

    # TODO: look up each variable in symbol table, if not found, throw an error

    def compile_letStatement(self) -> None: 
        # let # NOTE: previously checked
        self.forward()
        # varName
        if self.isIdentifier():
            name = self.JT.current_token
            index = self.ST.index_of(name)
            kind = self.ST.kind_of(name).value
            self.forward()
            ## TODO: ([ -> expression -> ])?
            #if self.eat('['):
            #    self.write_terminal()
            #    # expression
            #    self.compile_expression()
            #    # ]
            #    if self.eat(']'):
            #        self.write_terminal()
            # =
            if self.eat('='):
                self.forward()
                # expression
                self.compile_expression()
                # ;
                if self.eat(';'):
                    self.forward()
                    self.VMW.write_pop(kind, index)

    
    # PURPOSE:  Compiles a return statement.
    # return -> expression? -> ;
    #@wrap_non_terminal
    def compile_returnStatement(self) -> None: 
        # return # NOTE: previously checked
        self.forward()
        # expresssion?
        if not self.eat(';'):
            self.VMW.write_return()
            self.compile_expression()
        else:
            self.VMW.write_push('constant', 0)
            self.VMW.write_return()
        # ;
        if self.eat(';'):
            self.forward()


    # PURPOSE:  Compiles a while statement.
    # while -> ( -> expression -> ) -> { -> statements -> }
    # TODO: unique labels
    # TODO: negate not according to rules:
    """
        label L1
            compiled (expresison)
            not
            if-goto L2
            compiled (statements)
            goto L1
        label L2
        ...
    """
    def compile_whileStatement(self) -> None: 
        # while # NOTE: previously checked
        self.write_terminal()
        # (
        if self.eat('('):
            self.write_terminal()
            # expression
            self.compile_expression()
            # )
            if self.eat(')'):
                self.write_terminal()
                # {
                if self.eat('{'):
                    self.write_terminal()
                    # statements
                    self.compile_statements()
                    # }
                    if self.eat('}'):
                        self.write_terminal()


    # PURPOSE:  Compiles an expression.
    # term -> (op -> term)*
    def compile_expression(self) -> None:
        # term
        self.compile_term()
        # op*
        while self.isOp():
            op = self.JT.current_token
            self.forward()
            # term
            self.compile_term()
            # TODO: hardcoded behavior
            if op == '*':
                self.VMW.write_call('Math.multiply', 2)
            else:
                self.VMW.write_arithmetic(op)
    

    # PURPOSE: Compiles a term.
    # + integerConstant | + stringConstant | + keywordConstant | 
    # + varName | + varName [ expression ] | + varName . subroutineCall | 
    # + ( expression ) | + unaryOp term
    #@wrap_non_terminal
    def compile_term(self) -> None:
        # integerConstant
        if self.isIntegerConstant():
            self.VMW.write_push('constant', self.JT.current_token)
            self.forward()
        # TODO: stringConstant
        elif self.isStringConstant():
            print("STRING CONSTANT")
            pass
        # keywordConstant
        elif self.isKeyword():
            # TODO: where is 'this' ?
            # false | null
            if self.JT.current_token == 'false' or self.JT.current_token == 'null':
                self.VMW.write_push('constant', 0)
            # true
            else:
                self.VMW.write_push('constant', 0)
                self.VMW.write_arithmetic('~')
            self.forward()
        # varName
        elif self.isIdentifier():
            # TODO: search name in a symbol table, if not found, throw an error
            name = self.JT.current_token
            self.forward()
            # . subroutineCall
            if self.eat('.'):
                self.termName = name
                self.termName += self.JT.current_token
                self.forward()
                # subroutineCall
                self.compile_subroutineCall()
            else:
                segment = self.ST.kind_of(name).value
                index = self.ST.index_of(name)
                self.VMW.write_push(segment, index)
                # TODO: probably forward is useless

            ## TODO: [ expression ]
            #if self.eat('['):
            #    self.write_terminal()
            #    # expression
            #    self.compile_expression()
            #    # ]
            #    if self.eat(']'):
            #        self.write_terminal()
        # ( expression )
        elif self.eat('('):
            self.forward()
            # expression
            self.compile_expression()
            # )
            if self.eat(')'):
                self.forward()
        # unaryOp term
        elif self.isUnaryOp():
            unaryOp = self.JT.current_token
            self.forward()
            # term
            self.compile_term()
            self.VMW.write_arithmetic(unaryOp)


    # PURPOSE:  Compiles a (possibly empty) comma-separated list of expressions.
    # ( expression -> (, -> expression)* )?
    #@wrap_non_terminal
    def compile_expressionList(self) -> None:
        self.numArgs = 0
        while not self.eat(')'):
            # ,
            if self.eat(','):
                self.forward()
            # expressison
            self.compile_expression()
            self.numArgs += 1