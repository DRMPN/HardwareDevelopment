import sys
from JackTokenizer import *

# Effects the actual compilation output. Gets its input from a JackTokenizer 
#   and emits its parsed structure into an output file/stream. The output 
#   is generated by a series of compilexxx() routines, one for every syntactic
#   element xxx of the Jack grammar. The contract between these routines is that each
#   compilexxx() routine should read the syntactic construct xxx from the input,
#   advance() the tokenizer exactly beyond xxx, and output the parsing of xxx. Thus,
#   compilexxx() may only be called if indeed xxx is the next syntactic element of the input.

class CompilationEngine():
    

    # TODO:
    #   1. handle everything except expressions
    #   2. test it on the expressionless Square Dance
    #   3. extend the parser to handle expressions as well
    #   4. test it on the square dance and array test

    # TODO:
    # think aboyt reducing code redundancy with:
    #       compose non terminal
    #       +- level_indent


    # PURPOSE:  Creates a new compilation engine with the given input and output.
    #           The next routine called must be compileClass().
    # ASSUMES:  Passed paths are absolute.
    def __init__(self, input_path, output_path) -> None:
        
        self.JT = JackTokenizer(input_path)
        self.indent_level = 0  # indentation level
        
        try: self.out_file = open(output_path, 'w')
        except OSError: sys.exit(f'Unable to create {output_path}')

        self.forward()

    
    # PURPOSE:  Writes a line into an output file.
    # CHANGES:  file
    def write(self, line) -> None:
        self.out_file.write(line)
        

    # PURPOSE:  Closes output file and frees the memory.
    # CHANGES:  file
    def dispose(self) -> None:
        self.out_file.close()


    # PURPOSE:  Advances tokenizer by one token.
    # CHANGES:  JackTokenizer
    def forward(self) -> None:
        if self.JT.hasMoreTokens(): self.JT.advance()


    # PURPOSE:  Backtracks tokenizer by one token.
    # CHANGES:  JackTokenizer
    def backward(self) -> None:
        self.JT.current_token_number -= 1


    # PURPOSE:  Returns an XML tag for a passed non-terminal element.
    # RETURNS:  str
    def compose_non_terminal(self, word) -> str:
        indent = self.indent_level * '  ' # 2 spaces
        return f'{indent}<{word}>\n'


    # PURPOSE:  Returns an XML line for a current terminal element.
    # RETURNS:  str
    def compose_terminal(self) -> str:
        indent = self.indent_level * '  ' # 2 spaces
        token_type = self.JT.tokenType()
        token = self.get_current_token(token_type)
        return f'{indent}<{token_type.value}> {token} </{token_type.value}>\n'


    # PURPOSE:  Returns current token represented as a string.
    # RETURNS:  str
    def get_current_token(self, token_type: LexicalElement) -> str:
        if token_type == LexicalElement.KEYWORD: return self.JT.keyWord()
        elif token_type == LexicalElement.SYMBOL: return self.JT.symbol()
        elif token_type == LexicalElement.IDENTIFIER: return self.JT.identifier()
        elif token_type == LexicalElement.INT_CONST: return self.JT.intVal()
        elif token_type == LexicalElement.STRING_CONST: return self.JT.stringVal()


    #   while ( expression ) { statements }
    #      eat while -> code to handle 'while'
    #      eat (
    #      compileexpression()
    #      eat )
    #      eat {
    #      compile statements
    #      eat }


    # PURPOSE:  Compiles a complete class.
    # ASSUMES:  Already has a token to start with.
    # class -> className -> { -> classVarDec* -> subroutineDec* -> }
    def compileClass(self) -> None:
        # class
        if self.eat('class'):
            self.write(self.compose_non_terminal('class'))
            self.indent_level += 1
            self.write(self.compose_terminal())
            # className
            self.forward()
            self.write(self.compose_terminal())
            # {
            self.forward()
            if self.eat('{'):
                self.write(self.compose_terminal())

                # TODO: test this block of code properly, but should work as expected
                # classVarDec*
                self.forward()
                while self.eat('static') or self.eat('field'):
                    self.compileClassVarDec()
                    self.forward()
                # subroutineDec*
                while self.eat('constructor') or self.eat('function') or self.eat('method'):
                    self.compileSubroutine()
                    self.forward()

                # }
                if self.eat('}'):
                    self.write(self.compose_terminal())
                    # end
                    self.indent_level -= 1
                    self.write(self.compose_non_terminal('/class'))


    # eat(string) {
    # if currentToken != string
    #   error
    # else
    #   advance
    # }

    # PURPOSE:  Compares current token with a passed string.
    # RETURNS:  bool
    def eat(self, string) -> bool:
        return self.JT.current_token == string


    # PURPOSE:  Checks whether or not current token is keyword or identifier.
    #           Currently purpose is: int | char | boolean | className ?
    # RETURNS:  bool
    # TODO: reforge
    def isKeywordOrIdentifier(self) -> bool:
        token_type = self.JT.tokenType()
        return token_type == LexicalElement.KEYWORD or token_type == LexicalElement.IDENTIFIER


    # PURPOSE:  Checks whether or not current token is identifier or not.
    #           Current target is: className | subroutineName | varName
    # RETURNS:  bool
    def isIdentifier(self) -> bool:
        return self.JT.tokenType() == LexicalElement.IDENTIFIER


    # PURPOSE:  Checks whether or not current token is stringConstant or not.
    # RETURNS:  bool
    def isStringConstant(self) -> bool:
        return self.JT.tokenType() == LexicalElement.STRING_CONST

    
    # PURPOSE:  Checks whether or not current token is integerConstant or not.
    # RETURNS:  bool
    def isIntegerConstant(self) -> bool:
        return self.JT.tokenType() == LexicalElement.INT_CONST

    
    # PURPOSE:  Checks whether or not current token is op or not.
    # RETURNS:  bool
    def isOp(self) -> bool:
        op = ['+', '-', '*', '/', '&', '|', '<', '>', '=']
        return self.JT.current_token in op

    
    # PURPOSE:  Checks whether or not current token is unaryOp or not.
    # RETURNS:  bool
    def isUnaryOp(self) -> bool:
        unaryOp = ['-', '~']
        return self.JT.current_token in unaryOp


    # PURPOSE:  Compiles a static declaration or a field declaration.
    # static | field -> type -> varName -> (, -> varName )* -> ;
    def compileClassVarDec(self) -> None:
        # static | field
        # previously done
        self.write(self.compose_non_terminal('classVarDec'))
        self.indent_level += 1
        self.write(self.compose_terminal())
        # type
        self.forward()
        self.write(self.compose_terminal())
        # varName
        self.forward()
        self.write(self.compose_terminal())

        # (, -> varName )*
        # TODO: test this block of code properly, but should work as expected
        self.forward()
        self.write(self.compose_terminal())
        while not(self.eat(';')):
            self.forward()
            self.write(self.compose_terminal())

        # end
        self.indent_level -= 1
        self.write(self.compose_non_terminal('/classVarDec'))
    

    # PURPOSE:  Compiles a complete method, function, or constructor.
    # constructor | function | method -> void | type -> subroutineName -> ( -> parameterList -> ) -> subroutineBody
    def compileSubroutine(self) -> None:
        # constructor | function | method
        # previously done
        self.write(self.compose_non_terminal('subroutineDec'))
        self.indent_level += 1
        self.write(self.compose_terminal())
        
        # void | type
        self.forward()
        # TODO: type check
        if self.eat('void') or True: 
            self.write(self.compose_terminal())
            # subroutineName
            self.forward()
            self.write(self.compose_terminal())
            # (
            self.forward()
            if self.eat('('):
                self.write(self.compose_terminal())  
                # parameterList
                self.forward()
                self.compileParameterList()
                # )
                if self.eat(')'):
                    self.write(self.compose_terminal())
                    # subroutineBody
                    self.forward()
                    self.compileSubroutineBody()
        # end
        self.indent_level -= 1
        self.write(self.compose_non_terminal('/subroutineDec'))


    # PURPOSE:  Compiles a possibly empty parameter list, not including the enclosing ().
    # type -> varName -> (, -> varName)*
    def compileParameterList(self) -> None:
        self.write(self.compose_non_terminal('parameterList'))
        self.indent_level += 1
        # type
        if self.isKeywordOrIdentifier():
            self.write(self.compose_terminal())
            # varName
            self.forward()
            self.write(self.compose_terminal())

            # NOTE: should work as expected
            # (, -> varName)*
            self.forward()
            while not self.eat(')'):
                self.write(self.compose_terminal())
                self.forward()
        # end
        self.indent_level -= 1
        self.write(self.compose_non_terminal('/parameterList'))


    # PURPOSE:  Compiles a body of a subroutine.
    # { -> varDec* -> statements -> }
    def compileSubroutineBody(self) -> None:
        self.write(self.compose_non_terminal('subroutineBody'))
        self.indent_level += 1
        # {
        if self.eat('{'):
            self.write(self.compose_terminal())
            # varDec*
            self.forward()
            while self.eat('var'):
                self.compileVarDec()
                self.forward()
            # statements
            self.compileStatements()
            # }
            self.write(self.compose_terminal())
        # end
        self.indent_level -= 1
        self.write(self.compose_non_terminal('/subroutineBody'))


    # PURPOSE:  Compiles a var declaration.
    # var -> type -> varName -> (, -> varName)* -> ;
    def compileVarDec(self) -> None:
        self.write(self.compose_non_terminal('varDec'))
        self.indent_level += 1
        # var
        self.write(self.compose_terminal())
        # type
        self.forward()
        if self.isKeywordOrIdentifier():
            self.write(self.compose_terminal())
            # varName
            self.forward()
            if self.isKeywordOrIdentifier():
                self.write(self.compose_terminal())
                # (, -> varName)*
                self.forward()
                self.write(self.compose_terminal())
                while not(self.eat(';')):
                    self.forward()
                    self.write(self.compose_terminal())
        # end
        self.indent_level -= 1
        self.write(self.compose_non_terminal('/varDec'))
    
    
    # PURPOSE:  Compiles a sequence of statements, not including theenclosing {}.
    # statement*
    def compileStatements(self) -> None:
        self.write(self.compose_non_terminal('statements'))
        self.indent_level += 1

        while True:
            current_token = self.JT.current_token
            if current_token == 'do': 
                self.compileDo()
                self.forward()
            elif current_token == 'if': 
                self.compileIf()
            elif current_token == 'let': 
                self.compileLet()
                self.forward()
            elif current_token == 'return':
                self.compileReturn()
                self.forward()
            elif current_token == 'while': 
                self.compileWhile()
                self.forward()
            else:
                #print("BREAK ON EXHAUST")
                break

        # end
        self.indent_level -= 1
        self.write(self.compose_non_terminal('/statements'))
    

    # # PURPOSE:  Checks whether or not current token is a statement.
    # #           let | if | while | do | return
    # def isStatement(self) -> bool:
    #     current_token = self.JT.current_token
    #     statements = ['let', 'if', 'while', 'do', 'return']
    #     return current_token in statements


    # PURPOSE:  Compiles a do statement.
    # do -> subroutineCall -> ;
    def compileDo(self) -> None: 
        self.write(self.compose_non_terminal('doStatement'))
        self.indent_level += 1

        # do
        if self.isKeywordOrIdentifier():
            self.write(self.compose_terminal())
            # subroutineCall
            self.forward()
            self.compileSubroutineCall()
            # ;
            self.forward()
            if self.eat(';'):
                self.write(self.compose_terminal())

        # end
        self.indent_level -= 1
        self.write(self.compose_non_terminal('/doStatement'))


    # TODO...
    # subroutineName -> ( -> expressionList -> )
    # or
    # className | varName -> . -> subroutineName -> ( -> expressionList-> )
    # TODO reforge
    def compileSubroutineCall(self):
        # subroutineName | className | varName
        if self.isKeywordOrIdentifier():
            self.write(self.compose_terminal())
            # .
            self.forward()
            if self.eat('.'):
                self.write(self.compose_terminal())
                self.forward()
                # subroutineName
                if self.isKeywordOrIdentifier():
                    self.write(self.compose_terminal())
                    self.forward()
            # (
            if self.eat('('):
                self.write(self.compose_terminal())
                # expressionList
                self.forward()
                self.compileExpressionList()
                # )
                # NOTE: forward was in expressionList
                if self.eat(')'):
                    self.write(self.compose_terminal())


    # PURPOSE:  Compiles an if statement.
    # if -> ( -> expression -> ) -> { -> statements -> } -> ( else -> { -> statements -> } )?
    # FIXME: remove code redundancy
    def compileIf(self): 
        self.write(self.compose_non_terminal('ifStatement'))
        self.indent_level += 1

        # if
        if self.isKeywordOrIdentifier():
            self.write(self.compose_terminal())
            # (
            self.forward()
            if self.eat('('):
                self.write(self.compose_terminal())
                # expression
                self.forward()
                self.compileExpression()
                # )
                self.forward()
                if self.eat(')'):
                    self.write(self.compose_terminal())
                    # {
                    self.forward()
                    if self.eat('{'):
                        self.write(self.compose_terminal())
                        # statements
                        self.forward()
                        self.compileStatements()
                        # }
                        if self.eat('}'):
                            self.write(self.compose_terminal())
                        # else
                        self.forward()
                        if self.eat('else'):
                            self.write(self.compose_terminal())
                            # {
                            self.forward()
                            if self.eat('{'):
                                self.write(self.compose_terminal())
                                # statements
                                self.forward()
                                self.compileStatements()
                                # }
                                if self.eat('}'):
                                    self.write(self.compose_terminal())
                                    self.forward()
        # end
        self.indent_level -= 1
        self.write(self.compose_non_terminal('/ifStatement'))


    # PURPOSE:  Compiles a let statement.
    # let -> varName -> ([ -> expression -> ])? -> = -> expression -> ;
    def compileLet(self) -> None: 
        self.write(self.compose_non_terminal('letStatement'))
        self.indent_level += 1

        # let
        self.write(self.compose_terminal())
        # varName
        self.forward()
        if self.isKeywordOrIdentifier():
            self.write(self.compose_terminal())
            # ([ -> expression -> ])?
            self.forward()
            if self.eat('['):
                self.write(self.compose_terminal())
                # expression
                self.forward()
                self.compileExpression()
                # ]
                self.forward() # NOTE: clunky backward
                if self.eat(']'):
                    self.write(self.compose_terminal())
                    self.forward()
            # =
            self.write(self.compose_terminal())
            # expression
            self.forward()
            self.compileExpression()
            # ;
            self.forward()
            self.write(self.compose_terminal())

        # end
        self.indent_level -= 1
        self.write(self.compose_non_terminal('/letStatement'))


    # PURPOSE:  Compiles a while statement.
    # while -> ( -> expression -> ) -> { -> statements -> }
    def compileWhile(self) -> None: 
        self.write(self.compose_non_terminal('whileStatement'))
        self.indent_level += 1

        # while
        if self.isKeywordOrIdentifier():
            self.write(self.compose_terminal())
            # (
            self.forward()
            if self.eat('('):
                self.write(self.compose_terminal())
                # expression
                self.forward()
                self.compileExpression()
                # )
                self.forward()
                if self.eat(')'):
                    self.write(self.compose_terminal())
                    # {
                    self.forward()
                    if self.eat('{'):
                        self.write(self.compose_terminal())
                        # statements
                        self.forward()
                        self.compileStatements()
                        # }
                        if self.eat('}'):
                            self.write(self.compose_terminal())

        # end
        self.indent_level -= 1
        self.write(self.compose_non_terminal('/whileStatement'))


    # PURPOSE:  Compiles a return statement.
    # return -> expression? -> ;
    def compileReturn(self) -> None: 
        self.write(self.compose_non_terminal('returnStatement'))
        self.indent_level += 1

        # return
        self.write(self.compose_terminal())
        # expresssion?
        self.forward()

        # TODO: test with expressions
        if not self.eat(';'):
            self.compileExpression()
            self.forward()

        # ;
        # NOTE: forward was previously used
        self.write(self.compose_terminal())

        # end
        self.indent_level -= 1
        self.write(self.compose_non_terminal('/returnStatement'))


    # PURPOSE:  Compiles and expression.
    # term -> (op -> term)*
    def compileExpression(self): 
        self.write(self.compose_non_terminal('expression'))
        self.indent_level += 1

        # term
        self.compileTerm()
        # op
        if self.isOp():
            self.forward() # NOTE: clunky backward
            self.write(self.compose_terminal())
            # term
            self.forward()
            self.compileTerm()

        # end
        self.indent_level -= 1
        self.write(self.compose_non_terminal('/expression'))
    

    # PURPOSE: Compiles a term.
    # integerConstant | stringConstant | keywordConstant | varName | 
    # varName [ expression ] | subroutineCall | ( expression ) | unaryOp term
    def compileTerm(self):
        self.write(self.compose_non_terminal('term'))
        self.indent_level += 1

        # TODO: reforge
        if self.isKeywordOrIdentifier():
            self.write(self.compose_terminal())
            # NOTE: PEEK ONE TOKEN FORWARD
            self.forward()
            # .
            if self.eat('.'):
                self.write(self.compose_terminal())
                # subroutineCall
                self.forward()
                self.compileSubroutineCall()
            # [
            elif self.eat('['):
                self.write(self.compose_terminal())
                # expression
                self.forward()
                self.compileExpression()
                # ]
                self.forward()
                if self.eat(']'):
                    self.write(self.compose_terminal())
            else:
                self.backward() # NOTE: clunky backward
        
        # stringConstant
        if self.isStringConstant():
            self.write(self.compose_terminal())

        # integerConstant
        if self.isIntegerConstant():
            self.write(self.compose_terminal())

        # end
        self.indent_level -= 1
        self.write(self.compose_non_terminal('/term'))


    # PURPOSE:  Compiles a (possibly empty) comma-separated list of expressions.
    # ( expression -> (, -> expression)* )?
    def compileExpressionList(self):
        self.write(self.compose_non_terminal('expressionList'))
        self.indent_level += 1

        if self.eat(')'):
            pass
        else:
            while not self.eat(')'):
                # ,
                if self.eat(','):
                    self.write(self.compose_terminal())
                    self.forward()
                # expressison
                self.compileExpression()
                self.forward()

        # end
        self.indent_level -= 1
        self.write(self.compose_non_terminal('/expressionList'))   