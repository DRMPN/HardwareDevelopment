

// PURPOSE: represents a brick breaker game
// TODO: create a better description
class BrickBreakerGame {

    // NOTE: DO NOT FORGET ABOUT PERFORMANCE

    // TODO: add a decition about initial ball trajectory launch before the main game loop
    //       platform moves left -> ball goes left etc.
    // TODO: draw borders
    // TODO: add lose/win conditions
    //      TODO: add lifes
    //      TODO: add score
    // BIG TODO: if platform moves to the side when a ball touches it, then change 
    //           direction of the ball accordingly in direction of movement of the platform

    // objects of the game
    field Platform platform;
    field Ball ball;
    // list of bricks
    field array lob;

    // constants
    static int LEFT_BORDER, RIGHT_BORDER, TOP_BORDER, BOTTOM_BORDER;
    static int NUMBER_OF_BRICKS;


    // PURPOSE: constructs a new Brick Breaker game
    constructor BrickBreakerGame new() {

        do init();

        let platform = Platform.new(256, 220);
        let ball = Ball.new(256, 128);

        let lob = Array.new(NUMBER_OF_BRICKS);

        do createBricks();
        do drawBorders();

        return this;
    }


    // PURPOSE: initizlizes constants for a game
    // CHANGES: constants
    // NOTE:    increase platform movement speed -> increase side borders 
    method void init() {
        
        let LEFT_BORDER = 10;
        let RIGHT_BORDER = 502;
        
        let TOP_BORDER = 10;
        let BOTTOM_BORDER = 230;

        let NUMBER_OF_BRICKS = 9;
        
        return;
    }


    // PURPOSE: frees memory from a game
    // CHANGES: memory
    method void dispose() {

        do platform.dispose();
        do ball.dispose();

        do disposeBricks();
        do Memory.deAlloc(lob);

        do Memory.deAlloc(this);

        return;
    }


    // PURPOSE: creates bricks to break
    // CHANGES: lob
    method void createBricks() {
        let lob[0] = Brick.new(50, 50);
        let lob[1] = Brick.new(150, 50);
        let lob[2] = Brick.new(250, 50);
        let lob[3] = Brick.new(350, 50);
        let lob[4] = Brick.new(450, 50);

        let lob[5] = Brick.new(100,  70);
        let lob[6] = Brick.new(200, 70);
        let lob[7] = Brick.new(300, 70);
        let lob[8] = Brick.new(400, 70);
        return;
    }


    // PURPOSE: disposes bricks inside list of bricks
    // CHANGES: memory
    method void disposeBricks() {

        var int n;
        var int i;
        var Brick brick;

        let n = 0;
        let i = NUMBER_OF_BRICKS;

        while (n < i) {
            let brick = lob[n];
            if (~(brick = null)) { do brick.dispose(); }
            let n = n + 1;
        }

        return;
    }


    // PURPOSE: draws borders of playgraound area on the screen
    // CHANGES: screen

    // TODO: MEMORY PEEK POKE

    method void drawBorders() {
    //    var int memAddress;
    //    var int n;
    //    var int i;
    //    
    //    let memAddress = 16384+512;
    //    let n = 1;
    //    let i = 31;
    //    
    //    while (n < i) {
    //        do Memory.poke(memAddress+n, -1);
    //        let n = n + 1;
    //    }
        do Screen.setColor(true);
        do Screen.drawLine(8, 8, 504, 8);       // top border
        do Screen.drawLine(8, 8, 8, 232);       // left border
        do Screen.drawLine(8, 232, 504, 232);   // bottom border
        do Screen.drawLine(504, 8, 504, 232);   // right border
        
        return;
    }


    // PURPOSE: checks possible bounce between the platform and the ball
    // RETURNS: bool
    method bool isPlatformBounce() {
        var bool x_eq_check;
        var bool y_eq_check;
        let x_eq_check = (platform.getX1() = ball.getX1()) | (platform.getX2() = ball.getX2());
        let y_eq_check = platform.getY1() = ball.getY2();

        return (((x_eq_check | (ball.getX2() > platform.getX1())) & y_eq_check) &
                ((x_eq_check | (ball.getX1() < platform.getX2())) & y_eq_check));
    }


    // PURPOSE: checks possible bounce between a brick and the ball
    // RETURNS: bool

    // TODO: ADD X AND Y EQUALITY CHECK  
    // TODO: REMOVE CODE REDUNDANCY

    method bool isBottomBrickBounce(Brick brick) {
        var bool y_check;
        let y_check = brick.getY2() = ball.getY1(); 

        return (((ball.getX2() > brick.getX1()) & y_check) &
                ((ball.getX1() < brick.getX2()) & y_check));
    }

    method bool isTopBrickBounce(Brick brick) {
        var bool y_check;
        let y_check = brick.getY1() = ball.getY2();

        return (((ball.getX2() > brick.getX1()) & y_check) &
                ((ball.getX1() < brick.getX2()) & y_check));
    }

    method bool isLeftBrickBounce(Brick brick) {
        var bool x_check;
        let x_check = brick.getX1() = ball.getX2();
        
        return ((x_check & (ball.getY2() > brick.getY1())) &
                (x_check & (ball.getY1() < brick.getY2())));
    }

    method bool isRightBrickBounce(Brick brick) {
        var bool x_check;
        let x_check = brick.getX2() = ball.getX1();
        
        return ((x_check & (ball.getY2() > brick.getY1())) &
                (x_check & (ball.getY1() < brick.getY2())));
    }


    // PURPOSE: 

    // TODO: REMOVE CODE REDUNDANCY

    method void isAnyBrickBounce() {

        var int i;
        var int n;
        var Brick brick;

        let n = 0;
        let i = NUMBER_OF_BRICKS;

        while (n < i) {

            let brick = lob[n];

            if (~(brick = null)) {

                if (isTopBrickBounce(brick)) {
                    do ball.topBrickBounce();

                    do brick.erase();
                    do brick.dispose();
                    let lob[n] = null;
                }

                if (isBottomBrickBounce(brick)) {
                    do ball.bottomBrickBounce();

                    do brick.erase();
                    do brick.dispose();
                    let lob[n] = null;
                }

                if (isLeftBrickBounce(brick)) {
                    do ball.leftBrickBounce();

                    do brick.erase();
                    do brick.dispose();
                    let lob[n] = null;
                }

                if (isRightBrickBounce(brick)) {
                    do ball.rightBrickBounce();

                    do brick.erase();
                    do brick.dispose();
                    let lob[n] = null;
                }

            }

            let n = n + 1;
        }

        return;
    }


    // PURPOSE: runs brick breaker game
    method void run() {
        
        var char key;
        var bool exit;

        let exit = false;

        while (~exit) {

            let key = Keyboard.keyPressed();

            if (isPlatformBounce()) { do ball.platformBounce(); }

            do isAnyBrickBounce();
            
            do Sys.wait(10);
            
            do ball.move(LEFT_BORDER, RIGHT_BORDER, TOP_BORDER, BOTTOM_BORDER);

            if (key = 81)   { let exit = true; }                        // q
            if (key = 130)  { do platform.moveLeft(LEFT_BORDER); }      // left arrow
            if (key = 132)  { do platform.moveRight(RIGHT_BORDER); }    // right arrow

        }

        return;
    }

} // class