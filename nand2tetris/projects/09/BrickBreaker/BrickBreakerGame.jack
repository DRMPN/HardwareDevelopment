

// PURPOSE: represents a brick breaker game
// TODO: create a better description
class BrickBreakerGame {

    // NOTE: DO NOT FORGET ABOUT PERFORMANCE

    // TODO: add a decition about initial ball trajectory launch before the main game loop
    //       platform moves left -> ball goes left etc.
    // TODO: draw borders
    // TODO: add lose/win conditions
    //      TODO: add lifes
    //      TODO: add score
    // BIG TODO: if platform moves to the side when a ball touches it, then change 
    //           direction of the ball accordingly in direction of movement of the platform

    // objects of the game
    field Platform platform;
    field Ball ball;
    // list of bricks
    field array lob;

    // constants
    static int LEFT_BORDER, RIGHT_BORDER, TOP_BORDER, BOTTOM_BORDER;


    // PURPOSE: constructs a new Brick Breaker game
    constructor BrickBreakerGame new() {

        do init();

        let platform = Platform.new(256, 200);
        let ball = Ball.new(256, 128);
        let lob = Array.new(3);

        do createBricks();

        return this;
    }


    // PURPOSE: initizlizes constants for a game
    // CHANGES: constants
    // NOTE:    increase platform movement speed -> increase side borders 
    method void init() {
        
        let LEFT_BORDER = 5;
        let RIGHT_BORDER = 505;
        
        let TOP_BORDER = 4;
        let BOTTOM_BORDER = 252;
        
        return;
    }


    // PURPOSE: frees memory from a game
    // CHANGES: memory
    method void dispose() {

        do platform.dispose();
        do ball.dispose();

        do disposeBricks();
        // TODO: do lob.dispose(); isn't found, check why
        do Memory.deAlloc(lob);

        do Memory.deAlloc(this);

        return;
    }


    // PURPOSE: creates bricks to break
    // CHANGES: lob
    method void createBricks() {
        let lob[0] = Brick.new(100, 50);
        let lob[1] = Brick.new(200, 50);
        let lob[2] = Brick.new(300, 50);
        return;
    }


    // PURPOSE: disposes bricks inside list of bricks
    // CHANGES: memory
    method void disposeBricks() {

        var int n;
        var int i;
        var Brick brick;

        let n = 0;
        let i = 3;

        while (n < i) {
            let brick = lob[n];
            if (~(brick = null)) { do brick.dispose(); }
            let n = n + 1;
        }

        return;
    }


    // PURPOSE: checks possible bounce between the platform and the ball
    // RETURNS: bool
    
    // TODO: remove hardcoded values
    // y check depends on speed / size / initial position of the ball
    // x size = speed *10; y size = speed * 3 ... etc

    method bool isPlatformBounce() {
        var bool y_check;
        //let y_check = ( platform.getY1() < (ball.getY() + 4) ) & ( platform.getY2() > (ball.getY() + 4) );
        let y_check = platform.getY1() = (ball.getY() + 4);

        return (( (platform.getX1() < (ball.getX() + 4)) & y_check ) &
                (( (ball.getX() - 4) < (platform.getX2()) & y_check ) ));
    }


    // PURPOSE: checks possible bounce between a brick and the ball
    // RETURNS: bool

    // TODO: remove hardcoded values

    // TODO: add complete collision check
    //      between x1 and x2 and near y1 then top
    //      between x1 and x2 and near y2 then bottom
    //      near x2 and between y1 and y2 then left
    //      near x1 and between y1 and y2 then right

    method bool isBrickBounce(Brick brick) {
        var bool y_check;
        //let y_check = (ball.getY() - 4) < (brick.getY() + 15) & ( (ball.getY() + 4) > brick.getY()) ;
        let y_check = brick.getY2() = (ball.getY() - 4); 

        return ( (( (ball.getX() + 4) > brick.getX1() ) & y_check ) & 
                    ( ( (ball.getX() - 4) < brick.getX2() ) & y_check ) ); 
    }


    // PURPOSE: 

    // TODO: add top bounce and side bounces

    method void isAnyBrickBounce() {

        var int i;
        var int n;
        var Brick brick;

        let i = 3;
        let n = 0;

        while (n < i) {

            let brick = lob[n];

            if (~(brick = null)) {
                if (isBrickBounce(brick)) {
                    do ball.brickBounce();

                    do brick.erase();
                    do brick.dispose();
                    let lob[n] = null;
                }
            }

            let n = n + 1;
        }

        return;
    }


    // PURPOSE: runs brick breaker game
    method void run() {
        
        var char key;
        var bool exit;

        let exit = false;

        while (~exit) {

            let key = Keyboard.keyPressed();

            if (isPlatformBounce()) { do ball.platformBounce(); }

            do isAnyBrickBounce();
            
            do ball.move(LEFT_BORDER, RIGHT_BORDER, TOP_BORDER, BOTTOM_BORDER);

            //do Sys.wait(5);

            if (key = 81)   { let exit = true; }                        // q
            if (key = 130)  { do platform.moveLeft(LEFT_BORDER); }      // left arrow
            if (key = 132)  { do platform.moveRight(RIGHT_BORDER); }    // right arrow

        }

        return;
    }

} // class